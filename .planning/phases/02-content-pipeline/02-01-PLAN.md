---
phase: 02-content-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/spotify-data.ts
  - lib/dynamodb/music-data.ts
  - lib/dynamodb/schema.ts
  - app/actions/spotify.ts
  - types/music.ts
autonomous: true

must_haves:
  truths:
    - "User's top 6 artists appear after connecting Spotify"
    - "User's top 3 tracks appear after connecting Spotify"
    - "User's top 5 albums (derived from tracks) appear after connecting Spotify"
    - "Spotify data is cached in DynamoDB (not fetched repeatedly)"
    - "User cannot refresh data within 24-hour cooldown period"
  artifacts:
    - path: "lib/spotify-data.ts"
      provides: "Spotify API client for fetching top artists and tracks"
      exports: ["getTopArtists", "getTopTracks"]
    - path: "lib/dynamodb/music-data.ts"
      provides: "DynamoDB operations for music data and cooldown"
      exports: ["getMusicData", "putMusicData", "getLastRefresh", "canRefresh"]
    - path: "lib/dynamodb/schema.ts"
      provides: "Key structure constants for DynamoDB items"
      exports: ["MUSIC_SK", "METADATA_SK"]
    - path: "app/actions/spotify.ts"
      provides: "Server actions for fetching and refreshing Spotify data"
      exports: ["fetchSpotifyData", "refreshSpotifyData"]
    - path: "types/music.ts"
      provides: "TypeScript types for music data"
      exports: ["Artist", "Track", "Album", "MusicData"]
  key_links:
    - from: "app/actions/spotify.ts"
      to: "lib/spotify-data.ts"
      via: "getTopArtists, getTopTracks calls"
      pattern: "getTopArtists|getTopTracks"
    - from: "app/actions/spotify.ts"
      to: "lib/dynamodb/music-data.ts"
      via: "putMusicData, canRefresh calls"
      pattern: "putMusicData|canRefresh"
    - from: "lib/spotify-data.ts"
      to: "Spotify API"
      via: "fetch with decrypted access token"
      pattern: "api.spotify.com"
---

<objective>
Fetch user's top artists, tracks, and derived albums from Spotify API and cache in DynamoDB with cooldown enforcement.

Purpose: Enable the content pipeline by providing the music data that AI will use to generate bios and captions. Caching ensures we don't hit Spotify rate limits and public pages never call Spotify API.

Output: Server actions that fetch Spotify data, derive top albums from tracks, cache in DynamoDB, and enforce 24-hour refresh cooldown.
</objective>

<execution_context>
@/Users/mathewbroughton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mathewbroughton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-content-pipeline/02-RESEARCH.md

# Existing code from Phase 1 to build on
@lib/dynamodb.ts
@lib/kms.ts
@lib/spotify.ts
@auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Spotify API client and music types</name>
  <files>lib/spotify-data.ts, types/music.ts</files>
  <action>
Create TypeScript types for Spotify data:

**types/music.ts:**
- `Artist`: id, name, images (array of {url, width, height}), genres (string array)
- `Track`: id, name, artists (array of {id, name}), album (id, name, images, album_type), popularity (number)
- `Album`: id, name, artists (array of {id, name}), images (array), albumType, score (optional number for ranking)
- `MusicData`: artists (Artist[]), albums (Album[]), tracks (Track[]), cachedAt (number timestamp)
- `SpotifyTopArtistsResponse`, `SpotifyTopTracksResponse`: API response shapes

**lib/spotify-data.ts:**
- Import `decryptSpotifyToken` from `@/lib/spotify` (already exists from Phase 1)
- `getTopArtists(accessToken: string, limit: number = 6)`:
  - Fetch from `https://api.spotify.com/v1/me/top/artists?limit=${limit}&time_range=medium_term`
  - Handle 429 rate limit errors - parse `Retry-After` header, throw with message "Rate limited. Retry after N seconds"
  - Return normalized Artist[] (only needed fields)

- `getTopTracks(accessToken: string, limit: number = 50)`:
  - Fetch from `https://api.spotify.com/v1/me/top/tracks?limit=${limit}&time_range=medium_term`
  - Same rate limit handling
  - Return normalized Track[]

- `deriveTopAlbums(tracks: Track[], limit: number = 5)`:
  - Group tracks by album.id
  - Skip singles (album.album_type === 'single')
  - Calculate weighted score: sum of track.popularity values / track count
  - Sort by score descending, take top N
  - Return Album[] with score included

Use `medium_term` time range (6 months) for stable, representative data.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
- Artist, Track, Album, MusicData types exported from types/music.ts
- getTopArtists, getTopTracks, deriveTopAlbums functions exported from lib/spotify-data.ts
- Rate limit handling included with Retry-After parsing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamoDB operations for music data and cooldown</name>
  <files>lib/dynamodb/schema.ts, lib/dynamodb/music-data.ts</files>
  <action>
Create DynamoDB module for music data storage:

**lib/dynamodb/schema.ts:**
Define key structure constants (following single-table design from research):
```typescript
// Sort key patterns
export const MUSIC_SK = {
  ARTISTS: 'MUSIC#ARTISTS',
  ALBUMS: 'MUSIC#ALBUMS',
  TRACKS: 'MUSIC#TRACKS',
  METADATA: 'PROFILE#METADATA'
} as const

// Helper to build PK
export const userPK = (userId: string) => `USER#${userId}`
```

**lib/dynamodb/music-data.ts:**
- Import docClient from `@/lib/dynamodb` (already configured from Phase 1)
- Import schema constants

Functions:

`getMusicData(userId: string): Promise<MusicData | null>`
- Use BatchGetCommand to fetch ARTISTS, ALBUMS, TRACKS items in one call
- If any missing, return null (data not yet fetched)
- Combine into MusicData object

`putMusicData(userId: string, data: { artists: Artist[], albums: Album[], tracks: Track[] }): Promise<void>`
- Use TransactWriteCommand to atomically write all three items plus update metadata
- Include cachedAt timestamp on each item
- Update METADATA item with lastRefresh timestamp

`getLastRefresh(userId: string): Promise<number | null>`
- Query METADATA item
- Return lastRefresh timestamp or null if never refreshed

`canRefresh(userId: string, cooldownMs: number = 24 * 60 * 60 * 1000): Promise<boolean>`
- Get lastRefresh
- Return true if null OR (now - lastRefresh) > cooldownMs
- This is the cooldown check

Use consistent error handling - let DynamoDB errors propagate with descriptive messages.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
- Schema constants exported from lib/dynamodb/schema.ts
- getMusicData, putMusicData, getLastRefresh, canRefresh functions exported
- Uses transactions for atomic writes
- Cooldown check implemented
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Server Actions for Spotify data operations</name>
  <files>app/actions/spotify.ts</files>
  <action>
Create Server Actions for Spotify data fetching:

**app/actions/spotify.ts:**
```typescript
'use server'

import { auth } from '@/auth'
import { revalidatePath } from 'next/cache'
import { getTopArtists, getTopTracks, deriveTopAlbums } from '@/lib/spotify-data'
import { getMusicData, putMusicData, canRefresh } from '@/lib/dynamodb/music-data'
import { getSpotifyAccessToken } from '@/lib/spotify'
import type { MusicData } from '@/types/music'
```

Functions:

`fetchSpotifyData(): Promise<{ data: MusicData | null, error?: string }>`
- Get session with auth()
- If no session, return { data: null, error: 'Not authenticated' }
- Check if cached data exists with getMusicData
- If exists, return it
- If not, call refreshSpotifyData internally
- Wrapped in try/catch, return errors as { data: null, error: message }

`refreshSpotifyData(): Promise<{ data: MusicData | null, error?: string, cooldownRemaining?: number }>`
- Get session with auth()
- Check canRefresh - if false, calculate remaining cooldown time, return { data: null, error: 'Cooldown active', cooldownRemaining: ms }
- Get decrypted access token using getSpotifyAccessToken (uses KMS from Phase 1)
- Fetch artists and tracks in parallel with Promise.all
- Derive albums from tracks
- Store in DynamoDB with putMusicData
- Call revalidatePath('/profile') and revalidatePath('/dashboard') to refresh UI
- Return { data: { artists, albums, tracks, cachedAt: Date.now() } }

Important:
- Use proper error boundaries - don't let server action throw
- Return typed response objects for client handling
- The getSpotifyAccessToken function from lib/spotify.ts handles token decryption
  </action>
  <verify>
TypeScript compiles and dev server starts:
```bash
npx tsc --noEmit && npm run dev
```
  </verify>
  <done>
- fetchSpotifyData server action returns cached or fresh data
- refreshSpotifyData server action fetches from Spotify with cooldown enforcement
- Proper error handling with typed responses
- Uses existing KMS token decryption from Phase 1
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. Type checking passes:
```bash
npx tsc --noEmit
```

2. New files exist with expected exports:
```bash
ls -la lib/spotify-data.ts lib/dynamodb/schema.ts lib/dynamodb/music-data.ts app/actions/spotify.ts types/music.ts
```

3. Server actions are properly marked:
```bash
grep "'use server'" app/actions/spotify.ts
```
</verification>

<success_criteria>
- types/music.ts exports Artist, Track, Album, MusicData types
- lib/spotify-data.ts exports getTopArtists, getTopTracks, deriveTopAlbums
- lib/dynamodb/schema.ts exports key constants and userPK helper
- lib/dynamodb/music-data.ts exports getMusicData, putMusicData, getLastRefresh, canRefresh
- app/actions/spotify.ts exports fetchSpotifyData, refreshSpotifyData server actions
- All TypeScript compiles without errors
- Cooldown enforcement implemented (24-hour default)
- Album derivation uses weighted scoring (sum of track popularity / count)
</success_criteria>

<output>
After completion, create `.planning/phases/02-content-pipeline/02-01-SUMMARY.md`
</output>
