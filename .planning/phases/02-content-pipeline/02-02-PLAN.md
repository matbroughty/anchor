---
phase: 02-content-pipeline
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - lib/bedrock/client.ts
  - lib/bedrock/prompts.ts
  - lib/dynamodb/content.ts
  - app/actions/ai-content.ts
  - types/content.ts
autonomous: true

must_haves:
  truths:
    - "AI generates bio from user's top artists and tracks"
    - "AI generates caption for each top album"
    - "Generated content follows anti-cringe rules (no emojis, hype words, cliches)"
    - "User can regenerate bio if unsatisfied"
    - "User can regenerate individual album captions"
    - "AI content is stored in DynamoDB with timestamps"
  artifacts:
    - path: "lib/bedrock/client.ts"
      provides: "Configured Bedrock runtime client"
      exports: ["bedrockClient"]
    - path: "lib/bedrock/prompts.ts"
      provides: "System prompts with anti-cringe rules"
      exports: ["BIO_SYSTEM_PROMPT", "CAPTION_SYSTEM_PROMPT", "ANTI_CRINGE_RULES"]
    - path: "lib/dynamodb/content.ts"
      provides: "DynamoDB operations for AI-generated content"
      exports: ["getContent", "putBio", "putCaption", "getAllCaptions"]
    - path: "app/actions/ai-content.ts"
      provides: "Server actions for AI content generation"
      exports: ["generateBio", "generateAlbumCaptions", "regenerateBio", "regenerateCaption"]
    - path: "types/content.ts"
      provides: "TypeScript types for AI content"
      exports: ["Bio", "Caption", "ContentData"]
  key_links:
    - from: "app/actions/ai-content.ts"
      to: "lib/bedrock/client.ts"
      via: "Bedrock Converse API calls"
      pattern: "ConverseCommand"
    - from: "app/actions/ai-content.ts"
      to: "lib/dynamodb/content.ts"
      via: "putBio, putCaption calls"
      pattern: "putBio|putCaption"
    - from: "lib/bedrock/prompts.ts"
      to: "Claude model"
      via: "system prompt with ANTI_CRINGE_RULES"
      pattern: "NO emojis|NO hype words"
---

<objective>
Generate tasteful AI bios and album captions using AWS Bedrock Claude, with strict anti-cringe rules and regeneration support.

Purpose: The AI content is what makes Anchor special - it creates tasteful, authentic descriptions of users' music taste without marketing language or cliches. This is core product value.

Output: Bedrock integration that generates bio from music data, generates captions for each album, stores in DynamoDB with timestamps, and supports regeneration.
</objective>

<execution_context>
@/Users/mathewbroughton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mathewbroughton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-content-pipeline/02-RESEARCH.md

# References prior plan for music data types
@types/music.ts
@lib/dynamodb/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Bedrock client and anti-cringe prompts</name>
  <files>lib/bedrock/client.ts, lib/bedrock/prompts.ts, types/content.ts</files>
  <action>
Set up AWS Bedrock integration with carefully crafted prompts:

**types/content.ts:**
```typescript
export interface Bio {
  text: string
  generatedAt: number  // Unix timestamp
  editedAt?: number    // Set when user manually edits
}

export interface Caption {
  albumId: string
  text: string
  generatedAt: number
  editedAt?: number
}

export interface ContentData {
  bio: Bio | null
  captions: Caption[]
}
```

**lib/bedrock/client.ts:**
```typescript
import { BedrockRuntimeClient } from '@aws-sdk/client-bedrock-runtime'

export const bedrockClient = new BedrockRuntimeClient({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
  }
})
```

**lib/bedrock/prompts.ts:**
Define anti-cringe rules and prompts:

```typescript
export const ANTI_CRINGE_RULES = `
STRICT RULES - NEVER VIOLATE:
- NO emojis (zero tolerance)
- NO hype words: amazing, incredible, awesome, obsessed, fire, slaps, banger, vibes
- NO cliches: "soundtrack to my life", "this hits different", "can't live without", "speaks to my soul"
- NO superlatives: best, greatest, favorite, most
- NO marketing language: must-listen, essential, groundbreaking
- NO generic praise: talented, genius, masterpiece
- Use factual, conversational language only
- Be specific about what you observe, not how you feel about it
`

export const BIO_SYSTEM_PROMPT = `You are a music bio writer creating tasteful, authentic bios about users' music taste for a profile page.

${ANTI_CRINGE_RULES}

Write 2-3 sentences maximum. Focus on:
- Observable patterns in their listening (genres, eras, moods)
- Connections between artists they listen to
- Specific details rather than generic statements

Examples of GOOD bios:
- "Gravitates toward atmospheric production and introspective lyrics. The overlap between indie folk and electronic suggests an appreciation for textured soundscapes."
- "A clear throughline of 90s alternative runs through this collection, balanced with contemporary artists working in similar sonic territory."

Examples of BAD bios (never write like this):
- "This person has AMAZING taste! They're totally obsessed with incredible music that just hits different."
- "A true music lover whose playlist is pure fire. These artists are absolute legends."
`

export const CAPTION_SYSTEM_PROMPT = `You are writing a one-sentence caption for an album on a user's music profile page.

${ANTI_CRINGE_RULES}

Maximum 15 words. Focus on:
- Observable facts about the album or artist
- How this album relates to the user's overall listening patterns
- Specific musical qualities (production style, instrumentation, era)

Examples of GOOD captions:
- "This album's layered production aligns with your preference for dense, atmospheric records."
- "The only 2024 release in your rotation, suggesting immediate resonance."
- "Your most-played from this artist's catalog, by a significant margin."

Examples of BAD captions:
- "An absolute masterpiece that everyone needs to hear!"
- "This album just hits different - pure vibes."
`
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
- BedrockRuntimeClient configured in lib/bedrock/client.ts
- Anti-cringe rules defined with explicit forbidden patterns
- Bio and caption system prompts include few-shot examples of good vs bad
- Content types exported from types/content.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamoDB operations for AI content</name>
  <files>lib/dynamodb/content.ts</files>
  <action>
Create DynamoDB module for AI content storage:

**lib/dynamodb/content.ts:**
Import docClient from `@/lib/dynamodb` and schema from `@/lib/dynamodb/schema`

Add new sort key constants to schema.ts (or define here):
```typescript
const CONTENT_SK = {
  BIO: 'CONTENT#BIO',
  CAPTION_PREFIX: 'CONTENT#CAPTION#'  // Append albumId
} as const
```

Functions:

`getBio(userId: string): Promise<Bio | null>`
- GetCommand for PK=USER#{userId}, SK=CONTENT#BIO
- Return Bio object or null if not found

`putBio(userId: string, bio: Bio): Promise<void>`
- PutCommand for bio item
- Include all Bio fields (text, generatedAt, editedAt if exists)

`getCaption(userId: string, albumId: string): Promise<Caption | null>`
- GetCommand for PK=USER#{userId}, SK=CONTENT#CAPTION#{albumId}
- Return Caption or null

`getAllCaptions(userId: string): Promise<Caption[]>`
- QueryCommand with begins_with(SK, 'CONTENT#CAPTION#')
- Return array of Caption objects

`putCaption(userId: string, caption: Caption): Promise<void>`
- PutCommand for caption item

`getContent(userId: string): Promise<ContentData>`
- Combine getBio and getAllCaptions
- Return { bio, captions } object
- Use Promise.all for parallel queries

Timestamps are Unix milliseconds (Date.now()).
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
- getBio, putBio functions handle bio storage
- getCaption, putCaption, getAllCaptions handle caption storage
- getContent returns combined bio and captions
- SK pattern uses CONTENT#CAPTION#{albumId} for caption queries
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Server Actions for AI content generation</name>
  <files>app/actions/ai-content.ts</files>
  <action>
Create Server Actions for AI content generation:

**app/actions/ai-content.ts:**
```typescript
'use server'

import { auth } from '@/auth'
import { revalidatePath } from 'next/cache'
import { ConverseCommand } from '@aws-sdk/client-bedrock-runtime'
import { bedrockClient } from '@/lib/bedrock/client'
import { BIO_SYSTEM_PROMPT, CAPTION_SYSTEM_PROMPT } from '@/lib/bedrock/prompts'
import { getBio, putBio, putCaption, getAllCaptions } from '@/lib/dynamodb/content'
import { getMusicData } from '@/lib/dynamodb/music-data'
import type { Bio, Caption } from '@/types/content'
import type { Artist, Track, Album } from '@/types/music'
```

Functions:

`generateBio(): Promise<{ bio: Bio | null, error?: string }>`
- Get session, verify authenticated
- Get music data (artists, tracks) using getMusicData
- If no music data, return error "No music data available. Fetch Spotify data first."
- Build user message with artist names and track info
- Call Bedrock Converse API:
  - modelId: 'anthropic.claude-3-haiku-20240307-v1:0'
  - system: [{ text: BIO_SYSTEM_PROMPT }]
  - messages: [{ role: 'user', content: [{ text: userMessage }] }]
  - inferenceConfig: { maxTokens: 200, temperature: 0.6 }
- Extract text from response.output.message.content[0].text
- Create Bio object with generatedAt timestamp
- Save with putBio
- Revalidate paths
- Return { bio }

`generateAlbumCaptions(): Promise<{ captions: Caption[], error?: string }>`
- Get session, verify authenticated
- Get music data to get albums array
- For each album (max 5), generate caption sequentially (avoid Bedrock throttling):
  - Build user message with album name, artist, and listening context
  - Call Bedrock with CAPTION_SYSTEM_PROMPT
  - Save each caption with putCaption
- Sequential generation is intentional to avoid rate limits
- Return { captions: allCaptions }

`regenerateBio(): Promise<{ bio: Bio | null, error?: string }>`
- Same as generateBio but always generates fresh (overwrites existing)
- No check for existing bio

`regenerateCaption(albumId: string): Promise<{ caption: Caption | null, error?: string }>`
- Get music data, find specific album
- Generate single caption using same pattern
- Save and return

**Important implementation details:**
- Use temperature 0.6 for bio (some creativity, consistent tone)
- Use temperature 0.5 for captions (more consistent, shorter text)
- Sequential album caption generation to respect Bedrock limits
- Wrap all Bedrock calls in try/catch, return error responses
- Revalidate '/profile' and '/dashboard' paths after generation
  </action>
  <verify>
TypeScript compiles and dev server starts:
```bash
npx tsc --noEmit && npm run dev
```
  </verify>
  <done>
- generateBio creates bio from music data using Bedrock Claude
- generateAlbumCaptions creates captions for all albums sequentially
- regenerateBio overwrites existing bio with fresh generation
- regenerateCaption regenerates single album caption
- All use anti-cringe system prompts
- Content stored in DynamoDB with timestamps
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. Type checking passes:
```bash
npx tsc --noEmit
```

2. New files exist with expected structure:
```bash
ls -la lib/bedrock/ lib/dynamodb/content.ts app/actions/ai-content.ts types/content.ts
```

3. Anti-cringe rules are comprehensive:
```bash
grep -c "NO emojis\|NO hype words\|NO cliches" lib/bedrock/prompts.ts
```

4. Server actions use Bedrock Converse API:
```bash
grep "ConverseCommand" app/actions/ai-content.ts
```
</verification>

<success_criteria>
- lib/bedrock/client.ts exports configured BedrockRuntimeClient
- lib/bedrock/prompts.ts exports BIO_SYSTEM_PROMPT, CAPTION_SYSTEM_PROMPT, ANTI_CRINGE_RULES
- lib/dynamodb/content.ts exports getBio, putBio, getCaption, putCaption, getAllCaptions, getContent
- app/actions/ai-content.ts exports generateBio, generateAlbumCaptions, regenerateBio, regenerateCaption
- Anti-cringe rules explicitly forbid emojis, hype words, cliches, superlatives
- System prompts include few-shot examples of good vs bad content
- Content stored with generatedAt timestamps for audit trail
- Temperature set appropriately (0.5-0.6) for consistent tone
</success_criteria>

<output>
After completion, create `.planning/phases/02-content-pipeline/02-02-SUMMARY.md`
</output>
