---
phase: 03-publishing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/dynamodb/schema.ts
  - lib/dynamodb/public-profile.ts
  - app/actions/publish.ts
autonomous: true

must_haves:
  truths:
    - "User can toggle page between published and unpublished states"
    - "getPublicProfile returns null for unpublished users"
    - "getPublicProfile returns complete profile data for published users"
  artifacts:
    - path: "lib/dynamodb/public-profile.ts"
      provides: "Public profile query with React cache()"
      exports: ["getPublicProfile"]
    - path: "app/actions/publish.ts"
      provides: "Publish/unpublish server actions"
      exports: ["publishPage", "unpublishPage"]
  key_links:
    - from: "lib/dynamodb/public-profile.ts"
      to: "lib/dynamodb (DynamoDB client)"
      via: "GetCommand queries"
      pattern: "dynamoDocumentClient\\.send"
    - from: "app/actions/publish.ts"
      to: "lib/dynamodb (DynamoDB client)"
      via: "UpdateCommand"
      pattern: "UpdateCommand.*isPublic"
---

<objective>
Create data layer for public profiles and server actions to publish/unpublish pages.

Purpose: Enable users to control visibility of their profile pages. The data layer provides cached queries for public page rendering, while actions handle the isPublic toggle from the dashboard.

Output:
- `getPublicProfile(handle)` function wrapped in React cache() for deduplication
- `publishPage()` and `unpublishPage()` server actions with proper authentication and path revalidation
</objective>

<execution_context>
@/Users/mathewbroughton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mathewbroughton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-publishing/03-RESEARCH.md

# Existing data layer patterns
@lib/dynamodb/schema.ts
@lib/dynamodb/content.ts
@lib/dynamodb/music-data.ts
@lib/handle.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create public profile query function</name>
  <files>lib/dynamodb/public-profile.ts</files>
  <action>
Create a new file `lib/dynamodb/public-profile.ts` that exports a `getPublicProfile(handle: string)` function wrapped in React's cache().

The function should:
1. Query HANDLE#{handle} record to get userId (using existing pattern from lib/handle.ts)
2. Query USER#{userId} record to get displayName, handle, isPublic flag
3. Return null early if user doesn't exist OR isPublic is false/undefined
4. If published, fetch in parallel:
   - getMusicData(userId) from lib/dynamodb/music-data.ts
   - getContent(userId) from lib/dynamodb/content.ts
5. Return combined object with: displayName, handle, isPublic, bio (text only), artists, albums, tracks, captions

Import cache from 'react' (not next/cache). This is the React 19 cache() for request deduplication.

Use existing dynamoDocumentClient and TABLE_NAME from @/lib/dynamodb.
Use existing userPK from @/lib/dynamodb/schema.

Type the return value to include all fields needed for public page rendering.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit lib/dynamodb/public-profile.ts`</verify>
  <done>getPublicProfile function exists, uses React cache(), returns null for unpublished users, returns complete data for published users</done>
</task>

<task type="auto">
  <name>Task 2: Create publish/unpublish server actions</name>
  <files>app/actions/publish.ts</files>
  <action>
Create a new file `app/actions/publish.ts` with two server actions:

```typescript
'use server'

export async function publishPage(): Promise<{ success: boolean; error?: string }>
export async function unpublishPage(): Promise<{ success: boolean; error?: string }>
```

Each action should:
1. Check auth() session - return error if not authenticated
2. Use UpdateCommand to set isPublic = true/false on USER#{userId} record
3. Also set updatedAt = new Date().toISOString()
4. Get user's handle from their record and call revalidatePath(`/${handle}`) to bust ISR cache
5. Return { success: true } on success, { success: false, error: message } on failure

Import auth from @/lib/auth (existing auth config).
Import UpdateCommand, GetCommand from @aws-sdk/lib-dynamodb.
Import dynamoDocumentClient, TABLE_NAME from @/lib/dynamodb.
Import revalidatePath from next/cache.

Follow the typed response pattern from existing actions (data: T | null, error?: string style but simplified since these return no data).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit app/actions/publish.ts`</verify>
  <done>publishPage and unpublishPage server actions exist, check auth, update DynamoDB, revalidate public page path</done>
</task>

<task type="auto">
  <name>Task 3: Add isPublic type to schema constants</name>
  <files>lib/dynamodb/schema.ts</files>
  <action>
Update lib/dynamodb/schema.ts to document the isPublic field convention:

Add a comment block explaining that USER#{userId} records now include:
- isPublic: boolean (default false, controls public page visibility)

No code changes needed beyond documentation - the field is stored directly on the user record and doesn't need a separate sort key.

This documents the schema extension for future reference while keeping the file minimal.
  </action>
  <verify>File updated, no TypeScript errors</verify>
  <done>Schema file documents isPublic field location on USER records</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no TypeScript errors
2. New files exist at expected paths:
   - lib/dynamodb/public-profile.ts
   - app/actions/publish.ts
3. getPublicProfile uses React cache() wrapper
4. publishPage and unpublishPage check authentication
5. Both actions call revalidatePath after database update
</verification>

<success_criteria>
- getPublicProfile(handle) returns null for non-existent or unpublished users
- getPublicProfile(handle) returns complete profile data (displayName, bio, artists, albums, tracks, captions) for published users
- publishPage() sets isPublic=true and revalidates public page
- unpublishPage() sets isPublic=false and revalidates public page
- All functions follow existing codebase patterns (typed responses, proper error handling)
</success_criteria>

<output>
After completion, create `.planning/phases/03-publishing/03-01-SUMMARY.md`
</output>
